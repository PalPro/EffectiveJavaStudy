package asakichy.第08章プログラミング一般;

import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;

import asakichy.rule.OutLine;
import asakichy.rule.WholeOutLine;

public class 項目55注意して最適化する {

	@Test
	public void 最適化とは() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("パフォーマンスチューニングのこと。").e();

		o.l1("【どうすれば？】").e();
		o.l2("最適化に関して、誰もが知っておくべき３つの格言がある。").e();
		o.l2("William A. Wulfさん。").e();
		o.l3("全く馬鹿げた理由を含む他のどんな理由でもなく、");
		o.__("効率の名の下に（必ずしも効率を達成する訳でもないのに)、");
		o.__("さらにコンピューティングの罪が犯されている。").e();
		o.l2("Donald E. Knuthさん。").e();
		o.l3("僅かな効率、たとえば、時間の約９７％、については忘れるべきである。").e();
		o.l3("時期尚早の最適化は、すべての悪の根源である。").e();
		o.l2("M.A. Jacksonさん。").e();
		o.l3("最適化については２つの規則に従う。").e();
		o.l3("規則１ 最適化するな。").e();
		o.l3("規則２ （専門家のみに対して）まだ最適化するな。");
		o.__("すなわち、完全に明瞭で最適化されていない答えを得るまでは。").e();
	}

	@Test
	public void 指針_速いプログラムより良いプログラム() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("速いプログラムより良いプログラムを書くよう努める。").e();

		o.l1("【どうして？】").e();
		o.l2("良いプログラムは情報隠蔽の原則を具体化している。").e();
		o.l2("個々の決定は局所化されているので、他に影響なく後から変更できる。").e();
	}

	@Test
	public void 指針_アーキテクチャ設計時に考慮() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("パフォーマンスを制限するような設計上の決定を避けるように努める。").e();

		o.l1("【どうして？】").e();
		o.l2("アーキテクチャの欠陥は広範囲に渡り、変更が困難。").e();

		o.l1("【たとえば？】").e();
		o.l2("API。").e();
		o.l2("通信レベルのプロトコル。").e();
		o.l2("永続化形式。").e();
	}

	@Test
	public void 指針_API設計時に考慮() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("API設計の決定によるパフォーマンスの結果を考慮する。").e();

		o.l1("【たとえば？】").e();
		o.l2("クラスを不変にしたら、防御コピーのコストがかかることになる。").e();
		o.l2("スーパークラスがサブクラスのパフォーマンスの制約になる。").e();
	}

	@Test
	public void 指針_API設計をねじ曲げない() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("パフォーマンスのためにAPI設計をねじ曲げることをしない。").e();

		o.l1("【どうして？】").e();
		o.l2("良い設計と良いパフォーマンスは矛盾していない。").e();
		o.l2("ねじ曲げると、後の変更時、非常に苦労することになる。").e();
	}

	@Test
	public void 指針_測定ありき() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("個々の最適化の試みの前後に、必ず測定する。").e();

		o.l1("【どうして？】").e();
		o.l2("パフォーマンスが悪い場所は、決して類推できない。").e();
		o.l2("最適化の効果は、測定するまでわからない。").e();

		{
			/** 【補】Javaは「パフォーマンスモデル」が明確でない */
			// Javaは、基本操作の相対的コストが、明確には定義されていない。
			// プログラマが書いたコードとCPUが実行するものとの間の「意味的ギャップ」は、
			// 従来のコンパイル言語よりはかなり大きくなっている。
			// このため、最適化によるパフォーマンス結果の予想は非常に困難である。

			// パフォーマンスに関して、半分は正しかったり、あるいは全く嘘である
			// 都市伝説が数多く存在しているのはそのため。
		}

		o.l1("【どうすれば？】").e();
		o.l2("プロファイラを利用して計測する。").e();
		o.l2("IDEだけでなく、JDKにもプロファイラは添付されている。").e();
	}

	@Test
	public void まとめ() throws Exception {
		o.l1("良いプログラムを書くことが最優先。").e();
		o.l1("最適化するときは、その「前後で」計測必須。").e();
	}

	@Rule
	public OutLine o = new OutLine();

	@ClassRule
	public static WholeOutLine wo = new WholeOutLine();

}
