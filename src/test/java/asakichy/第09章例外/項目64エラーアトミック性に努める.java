package asakichy.第09章例外;

import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;

import asakichy.rule.OutLine;
import asakichy.rule.WholeOutLine;

public class 項目64エラーアトミック性に努める {

	@Test
	public void エラーアトミックとは() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("メソッドの処理が失敗した場合、オブジェクトをメソッド呼び出しの前の状態にしておく。").e();

		o.l1("【どうして？】").e();
		o.l2("回復することを期待されているチェックされる例外に対しては、特に求められる性質。").e();
	}

	@Test
	public void 方法_不変() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("不変オブジェクトを設計する。").e();

		o.l1("【どうして？】").e();
		o.l2("エラーアトミック性の実現に、別途コストがかからない。").e();
		o.l3("イミュータブルは、そもそもの性質として、オブジェクトの状態が変わることがないので。").e();
	}

	@Test
	public void 方法_処理前確認() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("オブジェクトの状態を変更する前に、妥当性確認を行っておく。").e();

		o.l1("【どうすれば？】").e();
		o.l2("操作を行う前にパラメータの正当性を検査する。").e();

		{
			/** 【補】計算の順序付け */
			// エラーアトミック性を達成するのに非常に近い関連のある方法として、
			// 失敗するかもしれない部分が、オブジェクトを変更する部分よりも前に行われるように、
			// 計算を順序付けするという方法がある。

			// たとえば、要素が何らかの順序に従ってソートされているTreeMapの場合を考える。

			// TreeMapへ要素を追加するためには、
			// 要素はTreeMapの順序付けを使用して比較できる型でなければならない。
			// この場合、わざわざパラメータチェックしなくても、
			// パラメータ誤った型の要素を追加しようとすると、
			// 木構造が実際に変更される前に、木構造中でその要素を検索した結果として、
			// ClassCastExceptionで失敗します。
		}
	}

	@Test
	public void 方法_回復コード() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("操作の途中で発生するエラーを捕らえて、");
		o.__("操作が始まる前の時点までオブジェクトの状態を戻す回復コードを書く。").e();

		o.l1("【どうすれば？】").e();
		o.l2("主に永続的なデータ構造に対して使用する。").e();
	}

	@Test
	public void 方法_一時コピー() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("オブジェクトの一時的コピーに対して操作を行い、");
		o.l2("操作が完了したらオブジェクトの内容を一時的コピーの内容で置き換える。").e();

		o.l1("【どうして？】").e();
		o.l2("一時的データ構造にデータが一旦保存されると").e();
		o.l2("計算を素早く行うことができる場合には一石二鳥。").e();

		o.l1("【たとえば？】").e();
		o.l2("java.util.Collection#sort()メソッド。").e();
		o.l3("ソートする前に入力のリストを配列に出力している。").e();
		o.l3("ソートのループ内で要素にアクセスするコストが減る。").e();
		o.l3("ソートに失敗したとき、元のリストに変更がないことを保証。").e();
	}

	@Test
	public void 適用外() throws Exception {
		o.l1("【どういうこと？】").e();
		o.l2("エラーアトミック性は一般に望ましいが、必達ではない。").e();

		o.l1("【どうして？】").e();
		o.l2("不整合から回復不可能なときもある。").e();
		o.l2("エラーアトミック性の保持に、コストが著しくかかかるときもある。").e();

		o.l1("【たとえば？】").e();
		o.l2("スレッドが適切な同期なしに、同一オブジェクトを同時に変更して、例外が発生したとき。").e();

		o.l1("【どうすれば？】").e();
		o.l2("回復できないときは、その旨APIコメントに書く。").e();
	}

	@Test
	public void まとめ() throws Exception {
		o.l1("オブジェクトが不整合なままプログラムが進むと、２次災害が発生し、原因の特定が困難になる。").e();
		o.l1("オブジェクトの整合性を維持するために、エラーアトミック性に努める。").e();
	}

	@Rule
	public OutLine o = new OutLine();

	@ClassRule
	public static WholeOutLine wo = new WholeOutLine();

}
